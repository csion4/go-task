先写功能，等整体出来后再重构出v1.0


stage配置json：
{
	"taskId": 0,
	"stages": [
		{
			"stageType": 1,
			"envs": {
				"gitUrl": "http://@10.124.192.127/guozh/ttt.git",
				"authType": "2",
				"gitUser": "guozh",
				"gitPasswd": "Tianti@2019",
				"branch": "master"
			}
		},
		{
			"stageType": 2,
			"envs": {
				"script": "mvn clean package"
			}
		},
		{
			"stageType": 3,
			"envs": {
				"url": "http://127.0.0.1:8080",
				"type": "get"
			}
		},
		{
			"stageType": 4,
			"envs": {
				"ip": "192.168.13.130",
				"userName": "root",
				"password": "123456",
				"source": "./target/xx.jar",
				"target": "/home/csion",
				"script": "ls"
			}
		}
	]
}



接口：
	1，添加工作节点
	2，获取工作节点（支持查询条件，不做分页）
	3，删除工作节点（校验是否有任务，如果有任务会在任务执行完后移除）
	4，获取任务执行记录，按照最后一次执行时间倒叙，分页，支持按照名称，工作节点查询
	5，点击任务跳转到任务详情界面

集群执行：
	1，工作节点选择，维护节点任务数，通过预占用方式加并发锁，任务结束时释放任务
	2，增加和节点间的监听，维护节点状态
	3，对节点各个阶段响应的任务状态处理
	4，存储任务执行记录所处节点标识，用于节点查询任务执行状态

工作模型：（一个好的idea可以让人瞬间兴奋起来，当别人无法给我提供舞台时，需要自己提供舞台来大展拳脚）
	1，配置文件和系统设置中可以调整工作模型
	2，配置模式只有两种：是否开启worker
		1不开启worker：
			1，master模型：该模型下，master节点可以有多个，master节点即承担服务端的角色也提供执行端的角色，且无法通过系统负载，需要第三方负载工具比如nginx，任务启动命令从前端通过第三方负载发送到哪个后端就会在哪个后端服务执行；
		2 开启worker：
			1，master-worker模型：该模型下，master节点可以有多个，同时可以添加worker节点，m、w都可以提供执行功能，任务负载调度由master节点集群完成（master节点会自动注册工作节点）
			2，worker模型：该模型在m-w模型基础上，单一职责，支持配置去除m，保证m只作为服务端，所有的任务都是在worker节点中执行；
			3，nM-Aw模型：在m-w模型基础上，支持配置单独的一些master可作为工作节点；

宕机处理：
	worker节点宕机：主节点定时探测清理
	master节点宕机；建立master节点间的交流机制，发现某个master节点异常时踢出，每个master节点启动时注册自身节点并且添加到集群中；
	服务探测策略：
		master模式下，无需开启探测，会出现某个几点宕机导致该节点任务异常的问题，暂时不处理
		worker模式下，master探测所有的工作节点（包括m和w），发现无响应时进行任务报错或者自动转移；

	
